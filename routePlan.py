import osmnx as ox
import networkx as nx
import folium
from folium.features import DivIcon

import routeFinding

# Should we plot & save the input map to check that it is the right map?
SANITY_CHECK = False

# load graph from GML
# For the last deliverable, change the file to 'graph_student.gml' generated by
# your chosen destination in load_map.py
graph = ox.io.load_graphml('graph_student.gml')

if SANITY_CHECK:
    # ...................................
    # Visualize map for sanity check
    fig, ax = ox.plot_graph(graph)
    fig.savefig('ubc_map.png')

    # ...................................
    # Visualize map with elevation for sanity check
    nc = ox.plot.get_node_colors_by_attr(graph, 'elevation', cmap='plasma')
    fig, ax = ox.plot_graph(graph, node_color=nc, node_size=5, edge_color='#333333', bgcolor='k')
    fig.savefig('ubc_elevation.png')


# =======================================================
# Main driving code starts here
#
# Choose a starting location. 
# Example location: the reconciliation pole on Main Mall.
#lat, lon = 49.2600154, -123.2510869
# Example location: Wreck Beach.
lat, lon = 50.8320, -113.9695

# Graph algorithm requires that start location is a graph node
# so find the one nearest our specified lat-long.
start = ox.nearest_nodes(graph, lon, lat)
startlat, startlon = graph.nodes[start]['y'], graph.nodes[start]['x']

goal_dist = 5000  # meters, must go at least this far

# Print debug info
print(f"Starting node: {start}")
print(f"Starting coordinates: ({startlat}, {startlon})")
print(f"Goal distance: {goal_dist} meters")

route, time = routeFinding.find_route(start, goal_dist, graph) # calls the main DFS function

# variable 'route' is a DiGraph, but we want a sequence of vertices along the solution path.
# take a look at these variables to see what's going on.
sorted_route = sorted(route.edges(), key=lambda x: route.edges[x[0], x[1]]['time'])

# Handle the case where no route was found
if not sorted_route:
    print("No route found. Using only the starting point.")
    route_vertices = [start]
else:
    # Create the path from the sorted edges
    route_vertices = [sorted_route[0][0]] + [edge[1] for edge in sorted_route]

print(f"Route length: {len(route_vertices)} nodes")

# If route has at least one node, use it; otherwise use the start node
end_node = route_vertices[-1] if route_vertices else start

# find coordinates of stopping point: last node on the route
endlat, endlon = graph.nodes[end_node]['y'], graph.nodes[end_node]['x']
print(f"End node: {end_node}")
print(f"End coordinates: ({endlat}, {endlon})")

# Calculate elevation gain
eg = routeFinding.total_elevation_gain(graph, route_vertices)
print(f"Total elevation gain: {eg} meters")

# =================================
# VISUALIZATION!!
# Complete the visualization by adding a finishing circle at the end!

# Only try to visualize if we have a valid route
if len(route_vertices) > 1:
    # In order to get the rainbow colors in our plot, we have to plot one edge of the
    # route at a time, calculating the color of each edge.
    try:
        route_gdf = ox.routing.route_to_gdf(graph, route_vertices)
        
        kwargs = {'style_kwds': dict(weight=5)}
        # If we just use route_gdf.iterrows(), we get Pandas rows, not GeoDataFrame rows
        for i, index in enumerate(route_gdf.index):
            row_gdf = route_gdf.loc[[index]]
            if i == 0:
                # Need to create the map for the first edge.
                m = row_gdf.explore(color=routeFinding.shade_given_time(i, time), **kwargs)
            else:
                # Add to the existing map.
                m = row_gdf.explore(m=m, color=routeFinding.shade_given_time(i, time), **kwargs)
    except Exception as e:
        print(f"Error creating route visualization: {e}")
        # Create a basic map centered on the start location if route visualization fails
        m = folium.Map(location=[startlat, startlon], zoom_start=14)
else:
    # Create a basic map if we don't have enough points for a route
    print("Not enough points for a route. Creating basic map.")
    m = folium.Map(location=[startlat, startlon], zoom_start=14)

# Place the elevation gain on the map at the end point of the workout.
folium.map.Marker(
    [endlat, endlon],
    icon=DivIcon(
        icon_size=(250,36),
        icon_anchor=(0,0),
        html=f'<div style="font-size: 20pt">Elevation Gain: {eg}m</div>',
    )
).add_to(m)

# Add green start circle.
folium.CircleMarker((startlat, startlon),
                    color='green', radius=10, fill=True).add_to(m)

# Add blue end circle
folium.CircleMarker((endlat, endlon),
                    color='blue', radius=10, fill=True).add_to(m)

filepath = "route_graph_workout.html"
m.save(filepath)
print(f"Map saved to {filepath}")